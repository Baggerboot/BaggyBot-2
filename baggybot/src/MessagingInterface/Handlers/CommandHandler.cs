using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using BaggyBot.Commands;
using BaggyBot.Configuration;
using BaggyBot.EmbeddedData;
using BaggyBot.MessagingInterface.Events;
using BaggyBot.Monitoring;

namespace BaggyBot.MessagingInterface.Handlers
{
	internal class CommandHandler : ChatClientEventHandler
	{
		private readonly Dictionary<string, Command> commands = new Dictionary<string, Command>();

		public override void Initialise()
		{
			var matchingTypes = Assembly.GetExecutingAssembly().DefinedTypes
				.Where(t => typeof(Command).IsAssignableFrom(t)
				&& !t.IsAbstract
				&& t.GetCustomAttribute(typeof(NonAutoGeneratedCommandAttribute)) == null);

			foreach (var type in matchingTypes)
			{
				if (!ConfigManager.Config.Interpreters.Enabled && typeof(ReadEvaluatePrintCommand).IsAssignableFrom(type))
				{
					if (type == typeof(Py))
					{
						var command = new Notify("The interactive Python interpreter is currently disabled. It can be enabled in the configuration file.");
						command.Client = Client;
						commands["py"] = command;
					}
					else if (type == typeof(Cs))
					{
						var command = new Notify("The interactive C# interpreter is currently disabled. It can be enabled in the configuration file.");
						command.Client = Client;
						commands["cs"] = command;
					}
				}
				else
				{
					var command = (Command)Activator.CreateInstance(type);
					command.Client = Client;
					commands[command.Name] = command;
				}

			}

			// Command list must be initialised before we can pass a reference to it to the Help command.
			var help = new Help(commands);
			help.Client = Client;
			commands["help"] = help;
		}

		public override void HandleMessage(MessageEvent ev)
		{
			var match = Bot.CommandIdentifiers.FirstOrDefault(id => ev.Message.Message.StartsWith(id));

			if (match == null)
			{
				return;
			}
			var cmdInfo = CommandArgs.FromMessage(match, ev.Message);
			ProcessCommand(cmdInfo);
		}

		private void HandleExistingCommand(CommandArgs cmdInfo)
		{
			bool isValid;
			if (commands[cmdInfo.Command].Permissions == PermissionLevel.BotOperator)
			{
				try
				{
					isValid = Client.Validate(cmdInfo.Sender);

				}
				catch (Exception)
				{
					cmdInfo.Reply("I am unable to validate your account.");
					return;
				}
			}
			else
			{
				isValid = true;
			}
			if (!isValid)
			{
				cmdInfo.ReturnMessage(Messages.CmdNotAuthorised);
				return;
			}

			// Don't gobble up exceptions when debugging
			if (ConfigManager.Config.DebugMode)
			{
				commands[cmdInfo.Command].Use(cmdInfo);
			}
			else
			{
				try
				{
					commands[cmdInfo.Command].Use(cmdInfo);
				}
				catch (Exception e)
				{
					var exceptionMessage = $"An unhandled exception (type: {e.GetType()}) occurred while trying to process your command! Exception message: \"{e.Message}\"";
					cmdInfo.ReturnMessage(exceptionMessage);
					// Previously, debugging information (filename and line number) were put in the error message.
					// That's dubm, no reason to bother the user with information that's useless to them. Log the exception instead.
					Logger.LogException(commands[cmdInfo.Command], e, $"processing the command \"{cmdInfo.Command} {cmdInfo.FullArgument}\"");
				}
			}
		}

		private bool ProcessCommand(CommandArgs cmdInfo)
		{
			// Inject bot information, but do not return.
			if (new[] { "help", "about", "info", "baggybot", "stats" }.Contains(cmdInfo.Command.ToLower()) && cmdInfo.Args.Length == 0)
			{
				cmdInfo.ReturnMessage(string.Format(Messages.CmdGeneralInfo, Bot.Version, ConfigManager.Config.StatsPage));
			}

			if (commands.ContainsKey(cmdInfo.Command))
			{
				HandleExistingCommand(cmdInfo);
				// The command exists, so the event should be consumed.
				return true;
			}
			else
			{
				// This doesn't look like a valid command. Is it a rem being set?
				if (cmdInfo.Command == "rem")
				{
					Logger.Log(this, "Saving rem");
					var newArgument = "say " + cmdInfo.FullArgument;
					((Alias)commands["alias"]).Use(CommandArgs.FromPrevious("alias", newArgument, cmdInfo));
					return true;
				}
				// Or perhaps an alias?
				if (((Alias)commands["alias"]).ContainsKey(Client.StatsDatabase, cmdInfo.Command))
				{
					var aliasedCommand = ((Alias)commands["alias"]).GetAlias(Client.StatsDatabase, cmdInfo.Command);
					if (cmdInfo.FullArgument == null)
					{
						aliasedCommand = aliasedCommand.Replace(" $args", "");
					}
					else
					{
						aliasedCommand = aliasedCommand.Replace("$args", cmdInfo.FullArgument);
					}
					Logger.Log(this, $"Calling aliased command: -{aliasedCommand}");

					ProcessCommand(CommandArgs.FromPrevious(aliasedCommand, cmdInfo));
					return true;
				}
				// If it's neither a rem nor an alias, it's not a valid command,
				// so we do not consume the event.
				return false;
			}
		}
	}
}